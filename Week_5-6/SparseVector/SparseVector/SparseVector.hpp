#ifndef SPARSE_VECTOR_HPP
#define SPARSE_VECTOR_HPP

#include "Vector.hpp"
#include "Matrix.hpp"
#include <vector>
#include <cassert>

template<class T>
class SparseVector{
public:
	// Creates an empty vector of dimensionality 0.
	SparseVector();
	// Creates a vector of dimensionality dim. It starts with 0 nonzero elements
	// which need to be set using setValue
	SparseVector(unsigned int dim);

	// Assignment operators and copy constructor should be automatically
	// generated by the compiler when using a std::vector for internal storing.
	// However, test that assignment works!

	// Sets the value v_i of the vector. if it does not exist it is added
    void setValue(unsigned int index, T value);
	
	// Returns the value v_i of the vector. Returns 0 if the value is not stored
    T getValue(unsigned int index) const;
	
	// Returns the dimensionality of the vector
	unsigned int size() const;
	
	// Returns the number stored elements
	unsigned int nonZeroes() const;
    
	// Returns the index of the ith stored nonzero entry (in increasing order)
	unsigned int indexNonZero(unsigned int i) const;
	// Returns the value of the ith stored nonzero entry (in increasing order)
	T valueNonZero(unsigned int i) const;
	
	//Adds x too the current vector
	SparseVector<T>& operator+= (SparseVector<T> const& x);
	//subtracts x from the current vector
	SparseVector<T>& operator-= (SparseVector<T> const& x);
    
    // For my own convinience
    void print_whole_vector();
private:
	//Add your data members here!
    unsigned int mdim;
    std::vector<int> mIndex;
    std::vector<T> mData;
};

template <class T>
SparseVector<T>::SparseVector()
{
    mdim = 0;
    mIndex = std::vector<int> (0, 0);
    mData = std::vector<T> (0, 0);
}

template <class T>
SparseVector<T>::SparseVector(unsigned int dim)
{
    mdim = dim;
    mIndex = std::vector<int> (0, 0);
    mData = std::vector<T> (0, 0);
}

template <class T>
void SparseVector<T>::setValue(unsigned int index, T value)
{
    // If Sparsevector has 0 dimensions it adds one and add the index and value
    if (mdim == 0)
    {
        mdim = index;
        mIndex.push_back(index);
        mData.push_back(value);
    }
    // If Sparsevector has dimensions but you add data outside of the dimensions is expands
    // the dimension to the dimension you choose and adds the corresponding index and value
//    else if (index > mdim)
//    {
//        mdim = index;
//        mIndex.push_back(index);
//        mData.push_back(value);
//    }
    else
    {
        // If you add values to a sparsevector of some dimension but its empty
        // it simply adds the index and value you choose
        if (mIndex.size() == 0)
        {
            mIndex.push_back(index);
            mData.push_back(value);
        }
        
        else if (mIndex.size() > 0)
        {
            // Checks if the corresponding index is already occupied
            std::vector<int>::const_iterator c;
            int q=0;
            for (c=mIndex.begin(); c!=mIndex.end(); c++)
            {
                if (*c == index)
                {
                    q=1;
                }
            }
            
            // If index is already occupied it deletes it and replaces the values with the given ones
            if (q == 1)
            {
                std::vector<int>::iterator low = lower_bound(mIndex.begin(), mIndex.end(), index);
                typename std::vector<T>::iterator test = mData.begin();
                
                long int x = low - mIndex.begin();
                
                mIndex.erase(low);
                mData.erase(test+x);
                
                mIndex.insert(low, index);
                mData.insert(test+x, value);
                
            }
            // Else it puts the index and value in the correct place in the Index and Value vector
            // (indicies always in increasing order)
            else
            {
                std::vector<int>::iterator low = lower_bound(mIndex.begin(), mIndex.end(), index);
                typename std::vector<T>::iterator test = mData.begin();
                
                long int x = low - mIndex.begin();

                mIndex.insert(low, index);
                mData.insert(test+x, value);
            }

        }
    }
    
//    // Checking entries of sparsevector just for sanity
//    std::vector<int>::const_iterator c;
//    for (c=mIndex.begin(); c!=mIndex.end(); c++)
//    {
//        std::cout << "Indices of sparse: " << *c << "\n";
//    }
//    
//    std::cout << mIndex.size() << "\n";
//    std::cout << mData.size() << "\n";
//    
//    typename std::vector<T>::const_iterator b;
//    for (b=mData.begin(); b!=mData.end(); b++)
//    {
//        std::cout << "Values of sparse: " << *b << "\n";
//    }
}

template <class T>
T SparseVector<T>::getValue(unsigned int index) const
{
    // Checks if the corresponding index is already occupied
    std::vector<int>::const_iterator c;
    int q=0;
    for (c=mIndex.begin(); c!=mIndex.end(); c++)
    {
        if (*c == index)
        {
            q=1;
        }
    }
    
    
    if (q == 1)
    {
        std::vector<int>::const_iterator low = lower_bound(mIndex.begin(), mIndex.end(), index);
        typename std::vector<T>::const_iterator test = mData.begin() + (low-mIndex.begin());
        
        return *test;
    }
    
    else
    {
        return 0;
    }
    
   
}

template <class T>
unsigned int SparseVector<T>::size() const
{
    return mdim;
}

template <class T>
unsigned int SparseVector<T>::nonZeroes() const
{
    return (unsigned int)(mIndex.size());
}

template <class T>
unsigned int SparseVector<T>::indexNonZero(unsigned int i) const
{
    return mIndex[i];
}

template <class T>
T SparseVector<T>::valueNonZero(unsigned int i)const
{
    return mData[i];
}

template <class T>
SparseVector<T>& SparseVector<T>::operator+= (SparseVector<T> const& x)
{
    assert(mdim == x.mdim);
    
    typename std::vector<int>::const_iterator a;
    typename std::vector<int>::const_iterator b;
    int if_not_in = 0;
    
    
    for (a=x.mIndex.begin(); a!=x.mIndex.end(); a++)
    {
        for (b=mIndex.begin(); b!=mIndex.end(); b++)
        {
            if (*a == *b)
            {
                
                auto temp = x.getValue(*a) + getValue(*a);
                
//                if (temp==0)
//                {
//                    std::vector<int>::iterator low = lower_bound(mIndex.begin(), mIndex.end(), *a);
//                    typename std::vector<T>::iterator test = mData.begin();
//                    long int x = low - mIndex.begin();
//                    
//                    mIndex.erase(low);
//                    mData.erase(test+x);
//                }
                
//                else
//                {
                    std::vector<int>::iterator low = lower_bound(mIndex.begin(), mIndex.end(), *a);
                    typename std::vector<T>::iterator test = mData.begin();
                    
                    long int x = low - mIndex.begin();
                    
                    
                    mData.erase(test+x);
                    mData.insert(test+x, temp);
//                }

                if_not_in = 1;
            }
        }
        
        if (if_not_in == 0)
        {
            auto temp = x.getValue(*a);
            
//            if (temp==0)
//            {
//                std::vector<int>::iterator low = lower_bound(mIndex.begin(), mIndex.end(), *a);
//                typename std::vector<T>::iterator test = mData.begin();
//                long int x = low - mIndex.begin();
//                
//                mIndex.erase(low);
//                mData.erase(test+x);
//            }
//            else
//            {
                std::vector<int>::iterator low = lower_bound(mIndex.begin(), mIndex.end(), *a);
                typename std::vector<T>::iterator test = mData.begin();
                long int x = low - mIndex.begin();
                
                mIndex.insert(low, *a);
                mData.insert(test+x, temp);
//            }    
            
        }
        if_not_in = 0;
    }
    
    return *this;
}

template <class T>
SparseVector<T>& SparseVector<T>::operator-= (SparseVector<T> const& x)
{
    assert(mdim == x.mdim);
    
    typename std::vector<int>::const_iterator a;
    typename std::vector<int>::const_iterator b;
    int if_not_in = 0;
    
    
    for (a=x.mIndex.begin(); a!=x.mIndex.end(); a++)
    {
        for (b=mIndex.begin(); b!=mIndex.end(); b++)
        {
            if (*a == *b)
            {
                
                auto temp = getValue(*a) - x.getValue(*a);
//                if (temp==0)
//                {
//                    std::vector<int>::iterator low = lower_bound(mIndex.begin(), mIndex.end(), *a);
//                    typename std::vector<T>::iterator test = mData.begin();
//                    long int x = low - mIndex.begin();
//                    
//                    mIndex.erase(low);
//                    mData.erase(test+x);
//                }
//                else
//                {
                    std::vector<int>::iterator low = lower_bound(mIndex.begin(), mIndex.end(), *a);
                    typename std::vector<T>::iterator test = mData.begin();
                    
                    long int x = low - mIndex.begin();
                    
                    
                    mData.erase(test+x);
                    mData.insert(test+x, temp);
//                }
                
                if_not_in = 1;
            }
        }
        
        if (if_not_in == 0)
        {
            auto temp = -x.getValue(*a);
//            if (temp==0)
//            {
//                std::vector<int>::iterator low = lower_bound(mIndex.begin(), mIndex.end(), *a);
//                typename std::vector<T>::iterator test = mData.begin();
//                long int x = low - mIndex.begin();
//                
//                mIndex.erase(low);
//                mData.erase(test+x);
//            }
//            else
//            {
                std::vector<int>::iterator low = lower_bound(mIndex.begin(), mIndex.end(), *a);
                typename std::vector<T>::iterator test = mData.begin();
                long int x = low - mIndex.begin();
                
                mIndex.insert(low, *a);
                mData.insert(test+x, temp);
//            }
            
            
        }
        if_not_in = 0;
    }
    if_not_in = 0;
    
    return *this;
}

template <class T>
void SparseVector<T>::print_whole_vector()
{
    std::cout << "Dimension of sparse vector: " <<  size() << "\n";
    
    typename std::vector<int>::const_iterator c;
    std::cout << "Indices of data in sparse: [";
    for (c=mIndex.begin(); c!=mIndex.end(); c++)
    {
        std::cout << " " << *c << " ";
    }
    std::cout << "]\n";
    
    
    typename std::vector<T>::const_iterator g;
    std::cout << "Data in sparse: [";
    for (g=mData.begin(); g!=mData.end(); g++)
    {
        std::cout << " " << *g << " ";
    }
    std::cout << "]\n";
}

// computes z= x+y, equivalent to z=x, z+=y
template<class T>
SparseVector<T> operator+(SparseVector<T> const& x, SparseVector<T> const& y)
{
    assert(x.size() == y.size());
    
    SparseVector<T> z(x.size());
    
    for (int a=0; a<x.nonZeroes(); a++)
    {
        z.setValue(x.indexNonZero(a), x.valueNonZero(a));
    }
    
    z += y;
    
    return z;
}



// computes z= x-y, equivalent to z=x, z-=y
template<class T>
SparseVector<T> operator-(SparseVector<T> const& x, SparseVector<T> const& y)
{
    assert(x.size() == y.size());
    
    SparseVector<T> z(x.size());
    
    for (int a=0; a<x.nonZeroes(); a++)
    {
        z.setValue(x.indexNonZero(a), x.valueNonZero(a));
    }
    
    z -= y;
    
    return z;
}


// Computes the matrix-vector product of a dense matrix and sparse vector z=Ax.
// The result is a dense vector.
template<class T>
Vector<T> operator* (Matrix<T> const& A, SparseVector<T> const& x)
{
    int original_vector_size = x.size();
    assert(A.GetNumberOfColumns() == original_vector_size);
    int new_vector_length = A.GetNumberOfRows();
    Vector<T> new_vector(new_vector_length);
    
    for (int i=0; i<new_vector_length; i++)
    {
        for (int j=0; j<original_vector_size; j++)
        {
            new_vector[i] += A(i,j)*x.getValue(j);
        }
    }
    
    return new_vector;
}

// Computes the matrix-vector product of a dense matrix and sparse vector z=x^TA.
// The result is a dense vector.
template<class T>
Vector<T> operator* (SparseVector<T> const& x, Matrix<T> const& A)
{
    int original_vector_size = x.size();
    assert(A.GetNumberOfRows() == original_vector_size);
    int new_vector_length = A.GetNumberOfColumns();
    Vector<T> new_vector(new_vector_length);
    
    for (int i=0; i<new_vector_length; i++)
    {
        for (int j=0; j<original_vector_size; j++)
        {
            new_vector[i] += x.getValue(j)*A(j,i);
        }
    }
    
    return new_vector;
}


#endif
